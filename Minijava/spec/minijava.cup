package syntax;
import syntax.ast.*;
import semantic.*;
import semantic.symtab.*;
import allocator.*;
import main.*;

action code {:
// Classes utilitaires pour constructions de paires de listes
	public class VarOrMethodList {		// membres de classes = ( fVar | Method) *
		public final ASTList<Var> vars;
		public final ASTList<Method> methods;
		
		public VarOrMethodList() {
			this.vars = new ASTList<>();
			this.methods = new ASTList<>();
		}
 	}
	
	class VarOrStmtList { // membre de methodes ou de blocs = ( Var | Stmt ) *
		public final ASTList<Var> vars;
		public final ASTList<Stmt> stmts;
		
		public VarOrStmtList() {
			this.vars = new ASTList<>();
			this.stmts = new ASTList<>();
		}
	}
:};


terminal PLUS, MINUS, TIMES, AND, LESS;
terminal SEP, LC, RC, LP, RP, LB, RB;
terminal CLASS, EXTENDS, MAIN, PRINTLN, PUBLIC, STATIC,
			STRING,  VOID, BOOL, INT, RETURN;
terminal Integer LIT_INT;
terminal String  IDENT;

nonterminal Axiom Axiom;
nonterminal KlassMain KlassMain;
nonterminal Klass Klass;
nonterminal VarOrMethodList KlassBody, NonEmptyKlassBody;
nonterminal Var Var;
nonterminal Method Method;
nonterminal VarOrStmtList MethodBody, NonEmptyMethodBody;
nonterminal Formal Formal;
nonterminal ASTList<Formal> FormalArgs;
nonterminal Ident Ident;
nonterminal Type Type;
nonterminal Stmt Stmt;
nonterminal Expr Expr;
nonterminal ExprOpBin ExprOpBin;
nonterminal ASTList<Klass>  KlassList;
nonterminal Parent;

precedence left AND;
precedence left LESS;
precedence left PLUS, MINUS;
precedence left TIMES;


Axiom ::= KlassMain:a KlassList:z							{: RESULT = new Axiom(a, z); RESULT.addPosition(axleft, zxright); :};

KlassMain ::= CLASS:a Ident:id LC
				PUBLIC STATIC VOID MAIN
				LP STRING LB RB Ident:arg RP
				LC Stmt:i RC RC:z							{: RESULT = new KlassMain(id, arg, i); RESULT.addPosition(axleft, zxright); :};

KlassList ::= /* Epsilon */									{: RESULT = new ASTList<>(); :}
			| KlassList:kl Klass:k							{: kl.add(k); RESULT = kl; :};

Klass ::= CLASS Ident Parent LC KlassBody RC;

Parent ::= /* Epsilon */									{: RESULT = new Ident("Object"); :}
		| EXTENDS Ident:id									{: RESULT = id; :};

KlassBody ::= /* Epsilon */									{: RESULT = new VarOrMethodList(); :}
			| NonEmptyKlassBody:kb							{: RESULT = kb; :};

NonEmptyKlassBody ::= Var:var								{: RESULT = new VarOrMethodList(); RESULT.vars.add(var); :}
					| Method:method							{: RESULT = new VarOrMethodList(); RESULT.methods.add(method); :}
					| NonEmptyKlassBody:kb Var:var			{: kb.vars.add(var); RESULT = kb; :}
					| NonEmptyKlassBody:kb Method:method	{: kb.methods.add(method); RESULT = kb; :};

Method ::= PUBLIC Type:type Ident:id LP
			FormalArgs:fm RP LC MethodBody:mb
			RETURN Expr:expr SEP							{: RESULT = new Method(type, id, fm, mb.args, mb.stmts, expr); :};

Formal ::= Type:type Ident:id								{: RESULT = new Formal(type, id); :};

FormalArgs ::= /* Epsilon */								{: RESULT = new ASTList<Formal>(); :}
			| FormalArgs:fa Formal:formal					{: fa.add(formal); RESULT = fa; :};

MethodBody ::= /* Epsilon */								{: RESULT = new VarOrStmtList(); :}
			| NonEmptyMethodBody:mb							{: RESULT = mb; :};

NonEmptyMethodBody ::= Var:var								{: RESULT = new VarOrStmtList(); RESULT.vars.add(var); :}
					| Stmt:stmt								{: RESULT = new VarOrStmtList(); RESULT.stmts.add(stmt); :}
					| NonEmptyMethodBody:mb Var:var			{: mb.vars.add(var); RESULT = mb; :}
					| NonEmptyMethodBody:mb Stmt:stmt		{: mb.stmts.add(stmt); RESULT = mb; :};

Var ::= Type:type Ident:id SEP								{: RESULT = new Var(type, id); :};

Type ::= BOOL												{: RESULT = new Type("boolean"); :}
		| INT												{: RESULT = new Type("int"); :}
		| Ident:id											{: RESULT = new Type(id.name); :};

Ident ::= IDENT:a											{: RESULT = new Ident(a); RESULT.addPosition(axleft,axright); :};

Stmt ::= PRINTLN:a LP Expr:b RP SEP:x						{: RESULT = new StmtPrint(b); RESULT.addPosition(axleft, xxright); :};

Expr ::= LIT_INT:a											{: RESULT = new ExprLiteralInt(a); RESULT.addPosition(axleft, axright); :}
		| LP Expr:expr RP									{: RESULT = expr; :}
		| ExprOpBin:exprOpBin								{: RESULT = exprOpBin; :};

ExprOpBin ::= Expr:op1 PLUS Expr:op2						{: RESULT = new ExprOpBin(op1, OPER.PLUS, op2); :}
			| Expr:op1 MINUS Expr:op2						{: RESULT = new ExprOpBin(op1, OPER.MINUS, op2); :}
			| Expr:op1 TIMES Expr:op2						{: RESULT = new ExprOpBin(op1, OPER.TIMES, op2); :}
			| Expr:op1 AND Expr:op2							{: RESULT = new ExprOpBin(op1, OPER.AND, op2); :}
			| Expr:op1 LESS Expr:op2						{: RESULT = new ExprOpBin(op1, OPER.LESS, op2); :};

