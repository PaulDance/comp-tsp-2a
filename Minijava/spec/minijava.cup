package syntax;
import syntax.ast.*;
import semantic.*;
import semantic.symtab.*;
import allocator.*;
import main.*;

action code {:
// Classes utilitaires pour constructions de paires de listes
	public class VarOrMeth { // membres de classes = ( fVar | Method) *
		ASTList<Var> vars;
		ASTList<Method> methods;
		
		public VarOrMeth() {
			this.vars = new ASTList<>();
			this.methods = new ASTList<>();
		}
 	}
	
	class VarOrStmt { // membre de methodes ou de blocs = ( Var | Stmt ) *
		ASTList<Var> vars;
		ASTList<Stmt> stmts;
		
		public VarOrStmt() {
			this.vars = new ASTList<>();  this.stmts = new ASTList<>();
		}
	}
:};


terminal PLUS, MINUS, TIMES, AND, LESS;
terminal SEP, LC, RC, LP, RP, LB, RB;
terminal CLASS, EXTENDS, MAIN, PRINTLN, PUBLIC, STATIC,
			STRING,  VOID;
terminal Integer LIT_INT;
terminal String  IDENT;

nonterminal Axiom Axiom;
nonterminal KlassMain KlassMain;
nonterminal Klass Klass;
nonterminal KlassBody KlassBody;
nonterminal Ident Ident;
nonterminal Stmt Stmt;
nonterminal Expr Expr;
nonterminal ExprOpBin ExprOpBin;
nonterminal ASTList<Klass>  KlassList;
nonterminal Parent;

precedence left AND;
precedence left LESS;
precedence left PLUS, MINUS;
precedence left TIMES;

///////////// Productions
Axiom ::= KlassMain:a KlassList:z
		   {: RESULT = new Axiom(a, z);
				RESULT.addPosition(axleft, zxright); :};

KlassMain ::= CLASS:a Ident:id LC
				PUBLIC STATIC VOID MAIN
				LP STRING LB RB Ident:arg RP LC Stmt:i RC RC:z
		   {: RESULT = new KlassMain(id, arg, i);
				RESULT.addPosition(axleft, zxright); :};

KlassList ::= /* Epsilon */									{: RESULT = new ASTList<>(); :}
			| KlassList:kl Klass:k							{: kl.add(k); RESULT = kl; :};

Klass ::= CLASS Ident Parent LC KlassBody RC;

Parent ::= /* Epsilon */									{: RESULT = null :}
		| EXTENDS Ident:id									{: RESULT = id :};

KlassBody ::= ;

Ident ::= IDENT:a
		   {: RESULT = new Ident(a);
				RESULT.addPosition(axleft,axright); :};

Stmt ::= PRINTLN:a LP Expr:b RP SEP:x
		   {: RESULT = new StmtPrint(b);
				RESULT.addPosition(axleft, xxright); :};

Expr ::= LIT_INT:a											{: RESULT = new ExprLiteralInt(a);
																RESULT.addPosition(axleft, axright); :}
		| LP Expr:expr RP									{: RESULT = expr; :}
		| ExprOpBin:exprOpBin								{: RESULT = exprOpBin; :};

ExprOpBin ::= Expr:op1 PLUS Expr:op2						{: RESULT = new ExprOpBin(op1, OPER.PLUS, op2); :}
			| Expr:op1 MINUS Expr:op2						{: RESULT = new ExprOpBin(op1, OPER.MINUS, op2); :}
			| Expr:op1 TIMES Expr:op2						{: RESULT = new ExprOpBin(op1, OPER.TIMES, op2); :}
			| Expr:op1 AND Expr:op2							{: RESULT = new ExprOpBin(op1, OPER.AND, op2); :}
			| Expr:op1 LESS Expr:op2						{: RESULT = new ExprOpBin(op1, OPER.LESS, op2); :};

